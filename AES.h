
//---------------------------------------------------------------------------
/**\addtogroup AES ****************************************************////@{
/**\file*********************************************************************
 *                                                                     \brief
 *  Заголовочный файл класса #aes.
 *
 *  @author Serge Trusov
 *  mailto: serge.trusov@gmail.com
 *
 ****************************************************************************
 */ 


#ifndef _AES_HPP
#define _AES_HPP


/** 
 *  Базовый тип данных обрабатываемый криптоалгоритмом.
 */
typedef unsigned char  byte;


/////////////////////////////////////////////////////////////////////////////

/** 
 *  Класс обеспечивает шифрование блока данных
 *  по стандартам AES-128, AES-192 и AES-256.
 *
 *  @note
 *  При компиляции можно выбрать поддерживаемые варианты длины ключа
 *  задав любую комбинацию макросов #AES_128, #AES_192 и #AES_256.
 *  По умолчанию будут поддерживаться все возможные длины ключей.
 */
class CAES {    // ECB

#if !defined(AES_128) && !defined(AES_192) && !defined(AES_256)
/// Обеспечивает поддержку ключей длиной 128 бит.       @ingroup AES
#define AES_128     
/// Обеспечивает поддержку ключей длиной 192 бит.       @ingroup AES
#define AES_192
/// Обеспечивает поддержку ключей длиной 256 бит.       @ingroup AES
#define AES_256
#endif

/////////////////////////////////////////////////////////////////////////////

public:

    /** 
     *  Значения, возвращаемые методами.
     *  Сигнализирует об успехе / ошибке.
     */
    enum   status   {
        Ok                  = 0,    ///< нет ошибки.
        wrong_key_lenght    = ~0    ///< неверная длина ключа.
    };

    /** 
     *  Размер блока шифротекста в байтах.
     *  По стандарту фиксирован.
     *  Может быть использован во внешних алгоритмах
     *  вызывающих методы класса.
     */
    static const unsigned int  block_size = 16;

    CAES(void){for(int ctr=0;ctr < sizeof(CAES);ctr++)((char*)this)[ctr] = 0;}

    /** 
     *  Шифрование блока данных.
     *  @note   Входной и выходной блоки могут совпадать !
     */
    void
      encrypt(
        const byte      in[block_size], ///< Входной блок данных.
        byte            out[block_size] ///< Выходной блок данных.  @see block_size
        );

    /** 
     *  Расшифровывание блока данных.
     *  @note   Входной и выходной блоки могут совпадать !
     */
    void
      decrypt(
        const byte      in[block_size], ///< Входной блок данных.
        byte            out[block_size] ///< Выходной блок данных. @see block_size
        );

    /** 
     *  Расширение ключа.
     *  Для (де)шифрации обязательно используется расширенный ключ.
     *  Необходимо вызвать метод перед первым encrypt() или decrypt()
     *  @note   Допустимые размеры ключа: 
     *  128 бит (если определён макрос #AES_128),
     *  192 бит (если определён макрос #AES_192),
     *  256 бит (если определён макрос #AES_265).
     */
    status
      expand_key(
        const byte    * key,            ///< Ключ.
        unsigned int  size            ///< Размер ключа в битах.
        );
   
/////////////////////////////////////////////////////////////////////////////

protected:

    /** 
     *  Количество раундов шифрования.
     *  Автоматически устанавливается в функции расширения ключа.
     */
    unsigned int    rounds; 

    /** 
     *  Криптоалгоритм обрабатывает блоки по 4 байта.
     */
    typedef unsigned int u32;

    /** 
     *  Расширенные (раундовые) ключи.
     *  Используются непосредственно для (де)шифрации текста.
     */
    u32     encryption_round_key[64],
            decryption_round_key[64];

    /** 
     *  Таблицы замен.
     */
    static  u32 s_box[256];     ///< Прямая замена
    static  u32 r_box[256];     ///< Обратная замена
    static  u32 ft[4][256];     ///< Расширенная прямая замена
    static  u32 rt[4][256];     ///< Расширенная обратная замена
    
    /** 
     *  Формирует таблицы замен.
     */
    void inline
      init_tables();
    
    /** 
     *  Образующий полином (базис) поля GF(2**8).
     *  определён так:     phi(x) = x**8 + x**4 + x**3 + x**1 + 1;
     */
    static const unsigned int   basis = 1<<8 | 1<<4 | 1<<3 | 1<<1 | 1<<0;

    /** 
     *  Генератор Галуа (Linear Feedback Shift Register)
     *  ненулевых элементов поля GF(2**8) в заданном базисе.
     *  Выполняет умножение на x по модулю phi(x). (xTime)
     */
    byte static inline 
      lfsr2(
        byte    a           ///< Предыдущее состойние генератора.
        );

    /** 
     *  Циклический сдвиг двойного слова влево на байт.
     */
    u32 static inline 
      rot_left_8( 
        u32 value           ///< Сдвигаемое значение.
        );

    /** 
     *  Преобразуете 4 байта в двойное слово (32бита).
     */
    u32 static inline 
      get( 
        const byte array[4] ///< Указатель на массив из 4-х байт.
        );

    /** 
     *  Помещает двойное слово (32бита) в массив из четырёх байт. 
     */
    void static inline 
      put( 
        u32  value,         ///< Исходные данные.
        byte array[4]       ///< Указатель на массив из четырёх байт. 
        );

    /** 
     *  Вспомогательная функция прямой табличной замены.
     *  Один из байт двойного слова используется в качестве индекса. 
     */
    u32 static inline
      fb(
        u32 byte,           ///< Слово содержащее байт.
        unsigned int position   ///< Позиция байта в слове.
        );

    /** 
     *  Вспомогательная функция обратной табличной замены.
     *  Один из байт двойного слова используется в качестве индекса. 
     */
    u32 static inline
      rb(
        u32 byte,           ///< Слово содержащее байт.
        unsigned int position   ///< Позиция байта в слове.
        );

};//class   aes


#endif//#ifndef _AES_HPP

///========================================================================//
///*} EOF

